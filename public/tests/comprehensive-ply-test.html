<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Comprehensive PLY Viewer Test - Pump Room Kiosk</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: system-ui, -apple-system, sans-serif;
      background: #1f1c1a; 
      color: #d4c5b0;
      min-height: 100vh;
    }
    .header {
      background: #2a2622;
      padding: 16px 24px;
      border-bottom: 1px solid #3d3530;
      display: flex;
      align-items: center;
      gap: 16px;
    }
    .header h1 { font-size: 20px; }
    .header p { font-size: 13px; opacity: 0.8; }
    
    .tabs {
      display: flex;
      background: #2a2622;
      border-bottom: 1px solid #3d3530;
    }
    .tab {
      padding: 12px 24px;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all 0.2s;
    }
    .tab:hover { background: #3d3530; }
    .tab.active { 
      border-bottom-color: #8b6f47; 
      background: #3d3530;
    }
    
    .controls {
      background: #2a2622;
      padding: 16px 24px;
      border-bottom: 1px solid #3d3530;
    }
    .control-row {
      display: flex;
      gap: 16px;
      align-items: flex-end;
      margin-bottom: 12px;
    }
    .control-row:last-child { margin-bottom: 0; }
    .control-group { display: flex; flex-direction: column; gap: 4px; }
    .control-group label { font-size: 12px; opacity: 0.8; }
    input[type="text"] {
      background: #1f1c1a;
      border: 1px solid #3d3530;
      color: #d4c5b0;
      padding: 8px 12px;
      border-radius: 4px;
      width: 450px;
      font-size: 14px;
    }
    input[type="text"]:focus { outline: none; border-color: #8b6f47; }
    button {
      background: #8b6f47;
      color: white;
      border: none;
      padding: 8px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }
    button:hover { background: #a08759; }
    button:disabled { background: #3d3530; cursor: not-allowed; }
    button.secondary {
      background: #3d3530;
    }
    button.secondary:hover { background: #4d4540; }
    
    .file-drop {
      border: 2px dashed #3d3530;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
      flex: 1;
    }
    .file-drop:hover, .file-drop.dragover {
      border-color: #8b6f47;
      background: rgba(139, 111, 71, 0.1);
    }
    .file-drop input { display: none; }
    
    .viewer-container {
      width: 100%;
      height: calc(100vh - 240px);
      position: relative;
      background: #1a1816;
    }
    #viewer-canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    
    .overlay {
      position: absolute;
      background: rgba(0,0,0,0.85);
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 13px;
      z-index: 100;
    }
    .status { top: 16px; left: 16px; max-width: 400px; }
    .status.loading { border-left: 3px solid #8b6f47; }
    .status.success { border-left: 3px solid #4ade80; }
    .status.error { border-left: 3px solid #f87171; }
    
    .info { bottom: 16px; left: 16px; }
    .info p { margin: 3px 0; }
    .info strong { color: #8b6f47; }
    
    .controls-help { bottom: 16px; right: 16px; text-align: right; }
    
    .progress {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.95);
      padding: 24px 32px;
      border-radius: 12px;
      text-align: center;
      min-width: 300px;
    }
    .progress .bar {
      height: 6px;
      background: #3d3530;
      border-radius: 3px;
      overflow: hidden;
      margin-top: 12px;
    }
    .progress .fill {
      height: 100%;
      background: linear-gradient(90deg, #8b6f47, #a08759);
      transition: width 0.2s;
    }
    
    .hidden { display: none !important; }
    
    .log-panel {
      position: absolute;
      top: 16px;
      right: 16px;
      width: 350px;
      max-height: 200px;
      background: rgba(0,0,0,0.9);
      border-radius: 8px;
      overflow: hidden;
      font-family: monospace;
      font-size: 11px;
    }
    .log-header {
      padding: 8px 12px;
      background: #3d3530;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .log-content {
      padding: 8px 12px;
      max-height: 150px;
      overflow-y: auto;
    }
    .log-content p { 
      margin: 2px 0; 
      word-break: break-all;
    }
    .log-content .error { color: #f87171; }
    .log-content .success { color: #4ade80; }
    .log-content .info { color: #60a5fa; }
  </style>
</head>
<body>
  <div class="header">
    <h1>üî¨ Comprehensive PLY Viewer Test</h1>
    <p>Testing Gaussian splat rendering for the Kingston Dry Dock Pump Room kiosk</p>
  </div>

  <div class="tabs">
    <div class="tab active" data-tab="url">Load from URL</div>
    <div class="tab" data-tab="file">Load Local File</div>
  </div>

  <div class="controls">
    <!-- URL Tab -->
    <div id="url-controls">
      <div class="control-row">
        <div class="control-group" style="flex: 1;">
          <label>PLY File URL</label>
          <input type="text" id="url-input" 
                 value="/splats/export_30000.ply"
                 placeholder="Local path or URL">
        </div>
        <button id="load-url-btn">Load from URL</button>
        <button id="clear-btn" class="secondary">Clear</button>
      </div>
      <div style="font-size: 12px; opacity: 0.7; margin-top: 8px;">
        ‚ÑπÔ∏è Put your PLY file in public/splats/ and use path like /splats/filename.ply
      </div>
    </div>
    
    <!-- File Tab -->
    <div id="file-controls" class="hidden">
      <div class="control-row">
        <div class="file-drop" id="file-drop">
          <input type="file" id="file-input" accept=".ply,.splat">
          <p>üìÅ <strong>Drop a PLY file here</strong> or click to browse</p>
          <p style="font-size: 12px; opacity: 0.7; margin-top: 8px;">Supports .ply files from Brush exports</p>
        </div>
      </div>
    </div>
  </div>

  <div class="viewer-container">
    <canvas id="viewer-canvas"></canvas>
    
    <div class="overlay status loading" id="status">Ready to load a PLY file...</div>
    
    <div class="progress hidden" id="progress">
      <div id="progress-label">Loading...</div>
      <div id="progress-text">0%</div>
      <div class="bar"><div class="fill" id="progress-fill" style="width: 0%"></div></div>
    </div>
    
    <div class="overlay info hidden" id="info">
      <p><strong>Points:</strong> <span id="point-count">-</span></p>
      <p><strong>File Size:</strong> <span id="file-size">-</span></p>
      <p><strong>Load Time:</strong> <span id="load-time">-</span></p>
      <p><strong>Format:</strong> <span id="format-info">-</span></p>
    </div>
    
    <div class="overlay controls-help">
      <p>üñ±Ô∏è Left-drag: Rotate</p>
      <p>üñ±Ô∏è Scroll: Zoom</p>
      <p>üñ±Ô∏è Right-drag: Pan</p>
    </div>
    
    <div class="log-panel" id="log-panel">
      <div class="log-header">
        <span>Debug Log</span>
        <button onclick="document.getElementById('log-content').innerHTML=''" style="padding: 2px 8px; font-size: 11px;">Clear</button>
      </div>
      <div class="log-content" id="log-content"></div>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    
    // DOM Elements
    const canvas = document.getElementById('viewer-canvas');
    const urlInput = document.getElementById('url-input');
    const loadUrlBtn = document.getElementById('load-url-btn');
    const clearBtn = document.getElementById('clear-btn');
    const fileInput = document.getElementById('file-input');
    const fileDrop = document.getElementById('file-drop');
    const statusEl = document.getElementById('status');
    const progressEl = document.getElementById('progress');
    const progressFill = document.getElementById('progress-fill');
    const progressText = document.getElementById('progress-text');
    const progressLabel = document.getElementById('progress-label');
    const infoEl = document.getElementById('info');
    const pointCountEl = document.getElementById('point-count');
    const fileSizeEl = document.getElementById('file-size');
    const loadTimeEl = document.getElementById('load-time');
    const formatInfoEl = document.getElementById('format-info');
    const logContent = document.getElementById('log-content');
    
    // Three.js objects
    let scene, camera, renderer, controls;
    let pointCloud = null;
    
    // Logging
    function log(message, type = '') {
      const p = document.createElement('p');
      p.className = type;
      p.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      logContent.appendChild(p);
      logContent.scrollTop = logContent.scrollHeight;
      console.log(message);
    }
    
    // UI Helpers
    function setStatus(message, type = 'loading') {
      statusEl.textContent = message;
      statusEl.className = 'overlay status ' + type;
    }
    
    function showProgress(show, percent = 0, label = 'Loading...') {
      progressEl.classList.toggle('hidden', !show);
      progressFill.style.width = percent + '%';
      progressText.textContent = Math.round(percent) + '%';
      progressLabel.textContent = label;
    }
    
    function formatBytes(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / 1024 / 1024).toFixed(2) + ' MB';
    }
    
    // Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById('url-controls').classList.toggle('hidden', tab.dataset.tab !== 'url');
        document.getElementById('file-controls').classList.toggle('hidden', tab.dataset.tab !== 'file');
      });
    });
    
    // URL transformation
    function transformUrl(url) {
      if (url.includes('dropbox.com')) {
        let direct = url.replace(/dl=[01]/, 'raw=1');
        direct = direct.replace('www.dropbox.com', 'dl.dropboxusercontent.com');
        log('Transformed Dropbox URL', 'info');
        return direct;
      }
      return url;
    }
    
    // Initialize Three.js
    function initThree() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1816);
      
      // Add subtle ambient light
      const ambient = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambient);
      
      // Camera
      camera = new THREE.PerspectiveCamera(
        60,
        canvas.clientWidth / canvas.clientHeight,
        0.01,
        1000
      );
      camera.position.set(2, 1.5, 3);
      
      // Renderer
      renderer = new THREE.WebGLRenderer({ 
        canvas, 
        antialias: true,
        powerPreference: 'high-performance'
      });
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      
      // Controls
      controls = new OrbitControls(camera, canvas);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.rotateSpeed = 0.5;
      controls.zoomSpeed = 1.0;
      controls.panSpeed = 0.5;
      
      // Grid helper
      const grid = new THREE.GridHelper(10, 20, 0x3d3530, 0x2a2622);
      scene.add(grid);
      
      // Axes helper
      const axes = new THREE.AxesHelper(1);
      scene.add(axes);
      
      // Start render loop
      animate();
      log('Three.js initialized', 'success');
    }
    
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    
    // PLY Parser - handles Brush's Gaussian splat format
    async function parsePLY(arrayBuffer, onProgress) {
      log('Starting PLY parse, size: ' + formatBytes(arrayBuffer.byteLength));
      
      // Decode header (always ASCII)
      const headerView = new Uint8Array(arrayBuffer, 0, Math.min(10000, arrayBuffer.byteLength));
      const headerText = new TextDecoder().decode(headerView);
      
      const headerEndIndex = headerText.indexOf('end_header');
      if (headerEndIndex === -1) {
        throw new Error('Invalid PLY: no end_header found');
      }
      
      const header = headerText.substring(0, headerEndIndex);
      log('PLY header parsed');
      
      // Parse format
      const formatMatch = header.match(/format (\w+)/);
      const format = formatMatch ? formatMatch[1] : 'ascii';
      log('Format: ' + format, 'info');
      
      // Parse vertex count
      const vertexMatch = header.match(/element vertex (\d+)/);
      if (!vertexMatch) {
        throw new Error('Could not find vertex count');
      }
      const vertexCount = parseInt(vertexMatch[1]);
      log('Vertex count: ' + vertexCount.toLocaleString(), 'info');
      
      // Parse properties
      const properties = [];
      const propRegex = /property (\w+) (\w+)/g;
      let match;
      while ((match = propRegex.exec(header)) !== null) {
        properties.push({ type: match[1], name: match[2] });
      }
      log('Properties: ' + properties.map(p => p.name).join(', '));
      
      // Detect Gaussian splat properties
      const hasOpacity = properties.some(p => p.name === 'opacity');
      const hasSH = properties.some(p => p.name.startsWith('f_dc_'));
      const hasScale = properties.some(p => p.name.startsWith('scale_'));
      const isGaussianSplat = hasOpacity || hasSH || hasScale;
      
      log(isGaussianSplat ? 'Gaussian splat PLY detected' : 'Standard PLY detected', 'info');
      
      // Calculate data start position
      const newlineAfterHeader = headerText.indexOf('\n', headerEndIndex);
      const dataStartByte = newlineAfterHeader + 1;
      
      // Property sizes and offsets
      const propSizes = {
        'float': 4, 'float32': 4,
        'double': 8, 'float64': 8,
        'int': 4, 'int32': 4,
        'uint': 4, 'uint32': 4,
        'short': 2, 'int16': 2,
        'ushort': 2, 'uint16': 2,
        'char': 1, 'int8': 1,
        'uchar': 1, 'uint8': 1
      };
      
      let vertexSize = 0;
      const propOffsets = {};
      for (const prop of properties) {
        propOffsets[prop.name] = vertexSize;
        vertexSize += propSizes[prop.type] || 4;
      }
      log('Vertex stride: ' + vertexSize + ' bytes');
      
      // Allocate arrays
      const positions = new Float32Array(vertexCount * 3);
      const colors = new Float32Array(vertexCount * 3);
      
      if (format === 'binary_little_endian' || format === 'binary_big_endian') {
        const littleEndian = format === 'binary_little_endian';
        const dataView = new DataView(arrayBuffer, dataStartByte);
        
        log('Parsing binary data...');
        
        for (let i = 0; i < vertexCount; i++) {
          const offset = i * vertexSize;
          
          // Position
          const x = dataView.getFloat32(offset + propOffsets['x'], littleEndian);
          const y = dataView.getFloat32(offset + propOffsets['y'], littleEndian);
          const z = dataView.getFloat32(offset + propOffsets['z'], littleEndian);
          
          positions[i * 3] = x;
          positions[i * 3 + 1] = y;
          positions[i * 3 + 2] = z;
          
          // Color from SH DC coefficients (Gaussian splat format)
          let r = 0.5, g = 0.5, b = 0.5;
          
          if (propOffsets['f_dc_0'] !== undefined) {
            // SH DC coefficients - need sigmoid-like conversion
            const sh0 = dataView.getFloat32(offset + propOffsets['f_dc_0'], littleEndian);
            const sh1 = dataView.getFloat32(offset + propOffsets['f_dc_1'], littleEndian);
            const sh2 = dataView.getFloat32(offset + propOffsets['f_dc_2'], littleEndian);
            
            // Convert SH to RGB (simplified - actual conversion is more complex)
            const SH_C0 = 0.28209479177387814;
            r = Math.max(0, Math.min(1, 0.5 + SH_C0 * sh0));
            g = Math.max(0, Math.min(1, 0.5 + SH_C0 * sh1));
            b = Math.max(0, Math.min(1, 0.5 + SH_C0 * sh2));
          } else if (propOffsets['red'] !== undefined) {
            // Standard RGB (0-255)
            r = dataView.getUint8(offset + propOffsets['red']) / 255;
            g = dataView.getUint8(offset + propOffsets['green']) / 255;
            b = dataView.getUint8(offset + propOffsets['blue']) / 255;
          }
          
          colors[i * 3] = r;
          colors[i * 3 + 1] = g;
          colors[i * 3 + 2] = b;
          
          // Progress callback
          if (i % 50000 === 0) {
            const progress = (i / vertexCount) * 100;
            onProgress?.(progress, 'Parsing vertices...');
            await new Promise(r => setTimeout(r, 0));
          }
        }
      } else {
        // ASCII format
        log('Parsing ASCII data...');
        const fullText = new TextDecoder().decode(arrayBuffer);
        const lines = fullText.substring(dataStartByte).trim().split('\n');
        
        for (let i = 0; i < Math.min(lines.length, vertexCount); i++) {
          const values = lines[i].trim().split(/\s+/).map(parseFloat);
          
          positions[i * 3] = values[0] || 0;
          positions[i * 3 + 1] = values[1] || 0;
          positions[i * 3 + 2] = values[2] || 0;
          
          // Try to get colors
          if (values.length > 5) {
            colors[i * 3] = (values[3] || 128) / 255;
            colors[i * 3 + 1] = (values[4] || 128) / 255;
            colors[i * 3 + 2] = (values[5] || 128) / 255;
          } else {
            colors[i * 3] = 0.5;
            colors[i * 3 + 1] = 0.5;
            colors[i * 3 + 2] = 0.5;
          }
          
          if (i % 50000 === 0) {
            const progress = (i / vertexCount) * 100;
            onProgress?.(progress, 'Parsing ASCII...');
            await new Promise(r => setTimeout(r, 0));
          }
        }
      }
      
      log('Parse complete', 'success');
      
      return {
        positions,
        colors,
        count: vertexCount,
        isGaussianSplat,
        properties: properties.map(p => p.name)
      };
    }
    
    // Create point cloud from parsed data
    function createPointCloud(data) {
      log('Creating point cloud geometry...');
      
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(data.positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(data.colors, 3));
      
      // Compute bounding box and center
      geometry.computeBoundingBox();
      geometry.computeBoundingSphere();
      geometry.center();
      
      // Material - use points with vertex colors
      const material = new THREE.PointsMaterial({
        size: 0.008,
        vertexColors: true,
        sizeAttenuation: true,
        transparent: true,
        opacity: 0.9
      });
      
      // Create points mesh
      const points = new THREE.Points(geometry, material);
      
      // Auto-fit camera
      const sphere = geometry.boundingSphere;
      if (sphere) {
        const dist = sphere.radius * 2.5;
        camera.position.set(dist * 0.6, dist * 0.4, dist * 0.8);
        controls.target.set(0, 0, 0);
        controls.update();
        log('Camera positioned at distance: ' + dist.toFixed(2));
      }
      
      return points;
    }
    
    // Load from URL
    async function loadFromUrl() {
      const url = urlInput.value.trim();
      if (!url) {
        setStatus('Please enter a URL', 'error');
        return;
      }
      
      clearViewer();
      if (!scene) initThree();
      
      const directUrl = transformUrl(url);
      log('Fetching: ' + directUrl);
      
      setStatus('Fetching file...', 'loading');
      showProgress(true, 0, 'Downloading...');
      
      const startTime = performance.now();
      
      try {
        const response = await fetch(directUrl);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        // Check content type
        const contentType = response.headers.get('content-type');
        log('Content-Type: ' + contentType);
        
        // Get content length if available
        const contentLength = response.headers.get('content-length');
        log('Content-Length: ' + (contentLength ? formatBytes(parseInt(contentLength)) : 'unknown'));
        
        showProgress(true, 20, 'Reading response...');
        const arrayBuffer = await response.arrayBuffer();
        
        log('Downloaded: ' + formatBytes(arrayBuffer.byteLength), 'success');
        fileSizeEl.textContent = formatBytes(arrayBuffer.byteLength);
        
        // Parse PLY
        const data = await parsePLY(arrayBuffer, (pct, label) => {
          showProgress(true, 20 + pct * 0.7, label);
        });
        
        showProgress(true, 95, 'Creating geometry...');
        
        // Create point cloud
        pointCloud = createPointCloud(data);
        scene.add(pointCloud);
        
        const loadTime = ((performance.now() - startTime) / 1000).toFixed(2);
        
        // Update UI
        showProgress(false);
        setStatus('‚úì Loaded successfully!', 'success');
        infoEl.classList.remove('hidden');
        pointCountEl.textContent = data.count.toLocaleString();
        loadTimeEl.textContent = loadTime + 's';
        formatInfoEl.textContent = data.isGaussianSplat ? 'Gaussian Splat PLY' : 'Standard PLY';
        
        log(`Loaded ${data.count.toLocaleString()} points in ${loadTime}s`, 'success');
        
      } catch (error) {
        log('Error: ' + error.message, 'error');
        showProgress(false);
        setStatus('Error: ' + error.message, 'error');
        
        if (error.message.includes('Failed to fetch') || error.message.includes('CORS')) {
          log('Tip: Try using the Local File tab to bypass CORS restrictions', 'info');
        }
      }
    }
    
    // Load from local file
    async function loadFromFile(file) {
      log('Loading local file: ' + file.name);
      log('File size: ' + formatBytes(file.size));
      
      clearViewer();
      if (!scene) initThree();
      
      setStatus('Reading file...', 'loading');
      showProgress(true, 0, 'Reading file...');
      
      const startTime = performance.now();
      
      try {
        const arrayBuffer = await file.arrayBuffer();
        fileSizeEl.textContent = formatBytes(arrayBuffer.byteLength);
        
        // Parse PLY
        const data = await parsePLY(arrayBuffer, (pct, label) => {
          showProgress(true, pct * 0.9, label);
        });
        
        showProgress(true, 95, 'Creating geometry...');
        
        // Create point cloud
        pointCloud = createPointCloud(data);
        scene.add(pointCloud);
        
        const loadTime = ((performance.now() - startTime) / 1000).toFixed(2);
        
        // Update UI
        showProgress(false);
        setStatus('‚úì ' + file.name + ' loaded!', 'success');
        infoEl.classList.remove('hidden');
        pointCountEl.textContent = data.count.toLocaleString();
        loadTimeEl.textContent = loadTime + 's';
        formatInfoEl.textContent = data.isGaussianSplat ? 'Gaussian Splat PLY' : 'Standard PLY';
        
        log(`Loaded ${data.count.toLocaleString()} points in ${loadTime}s`, 'success');
        
      } catch (error) {
        log('Error: ' + error.message, 'error');
        showProgress(false);
        setStatus('Error: ' + error.message, 'error');
      }
    }
    
    // Clear viewer
    function clearViewer() {
      if (pointCloud) {
        scene.remove(pointCloud);
        pointCloud.geometry.dispose();
        pointCloud.material.dispose();
        pointCloud = null;
      }
      infoEl.classList.add('hidden');
      setStatus('Ready to load a PLY file...', 'loading');
    }
    
    // Event Listeners
    loadUrlBtn.addEventListener('click', loadFromUrl);
    clearBtn.addEventListener('click', clearViewer);
    urlInput.addEventListener('keypress', e => { if (e.key === 'Enter') loadFromUrl(); });
    
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) loadFromFile(file);
    });
    
    fileDrop.addEventListener('click', () => fileInput.click());
    fileDrop.addEventListener('dragover', (e) => {
      e.preventDefault();
      fileDrop.classList.add('dragover');
    });
    fileDrop.addEventListener('dragleave', () => {
      fileDrop.classList.remove('dragover');
    });
    fileDrop.addEventListener('drop', (e) => {
      e.preventDefault();
      fileDrop.classList.remove('dragover');
      const file = e.dataTransfer.files[0];
      if (file) loadFromFile(file);
    });
    
    // Handle resize
    window.addEventListener('resize', () => {
      if (renderer && camera) {
        const w = canvas.clientWidth;
        const h = canvas.clientHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      }
    });
    
    // Initialize
    log('PLY Viewer Test initialized', 'success');
    log('Ready to load PLY files from URL or local disk');
  </script>
</body>
</html>